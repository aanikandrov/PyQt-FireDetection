# -*- coding: utf-8 -*-
import sys
import time
from collections import Counter

import cv2
import numpy as np
# Form implementation generated from reading ui file 'D:/design.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtWidgets
from PyQt5.QtCore import Qt, QThreadPool
from PyQt5.QtGui import QPixmap, QImage
from PyQt5.QtWidgets import QWidget, QLabel, QGridLayout, QFileDialog, QGraphicsScene, QGraphicsView

from ultralytics import YOLO

import VideoPlayer
import os

import Vision

import xml.etree.ElementTree as ET

from xml.dom import minidom


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):

        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(550, 450)
        MainWindow.setFixedSize(550, 450)

        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")

        self.tabVideo = QtWidgets.QTabWidget(self.centralwidget)
        self.tabVideo.setGeometry(QtCore.QRect(10, 10, 700, 550))

        self.tabVideo.setObjectName("tabVideo")
        self.tab = QtWidgets.QWidget()
        self.tab.setObjectName("tab")

        # --- --- --- --- --- --- --- --- --- --- --- ---
        # Image

        self.tabImage = QtWidgets.QWidget()
        self.tabImage.setObjectName("tab_image")
        self.tabVideo.addTab(self.tabImage, "")

        self.tabImage_labelDirectory = QtWidgets.QLabel('directory', self.tabImage)
        self.tabImage_labelDirectory.setGeometry(QtCore.QRect(300, 30, 70, 25))
        self.tabImage_labelDirectory.setObjectName("tabImage_labelDirectory")

        self.tabImage_pushOpen = QtWidgets.QPushButton('Open', self.tabImage)
        self.tabImage_pushOpen.setGeometry(QtCore.QRect(380, 30, 70, 20))
        self.tabImage_pushOpen.setObjectName("tabImage_pushOpen")

        self.tabImage_pushPredict = QtWidgets.QPushButton('Predict', self.tabImage)
        self.tabImage_pushPredict.setGeometry(QtCore.QRect(380, 60, 70, 20))
        self.tabImage_pushPredict.setObjectName("tabImage_pushPredict")
        self.tabImage_pushPredict.setEnabled(False)

        self.tabImage_graphicsView = QGraphicsView(self.tabImage)
        self.tabImage_graphicsView.setGeometry(20, 20, 350, 350)

        # --- --- --- --- --- --- --- --- --- --- --- ---
        # Camera

        self.tab_camera = QtWidgets.QWidget()
        self.tab_camera.setObjectName("tabCamera")
        self.tabVideo.addTab(self.tab_camera, "")

        self.tabCamera_label = QtWidgets.QLabel(self.tab_camera)
        self.tabCamera_label.setGeometry(QtCore.QRect(20, 20, 350, 250))
        self.tabCamera_label.setText("")
        self.tabCamera_label.setObjectName("tabCamera")
        self.tabCamera_label.setStyleSheet("border: 2px solid black; padding: 10px;")

        self.tabCamera_pushPlay = QtWidgets.QPushButton('Play (without prediction)', self.tab_camera)
        self.tabCamera_pushPlay.setGeometry(QtCore.QRect(380, 30, 140, 25))
        self.tabCamera_pushPlay.setObjectName("tabCamera_pushPlay")

        self.tabCamera_pushPredict = QtWidgets.QPushButton('Predict', self.tab_camera)
        self.tabCamera_pushPredict.setGeometry(QtCore.QRect(380, 60, 70, 25))
        self.tabCamera_pushPredict.setObjectName("tabCamera_pushPredict")

        MainWindow.setCentralWidget(self.centralwidget)
        self.tabVideo.raise_()
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)



    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))

        self.tabVideo.setTabText(self.tabVideo.indexOf(self.tab_camera), _translate("MainWindow", "Camera"))
        self.tabVideo.setTabText(self.tabVideo.indexOf(self.tabImage), _translate("MainWindow", "Image"))


    def functionaliti(self, MainWindow):
        self.thread_pool = QThreadPool()

        self.tabCamera_pushPlay.clicked.connect(self.video)
        self.tabCamera_pushPredict.clicked.connect(self.start_predict)

        self.tabImage_pushOpen.clicked.connect(self.open_image_2)
        self.tabImage_pushPredict.clicked.connect(self.predict_image_2)

        self.is_predict = False
        self.run_flag = True



    def open_image_2(self):

        options = QFileDialog.Options()

        file_name, _ = QFileDialog.getOpenFileName(None, "Выберите изображение", "",
                                                   "Images (*.png *.jpg *.jpeg)", options=options)

        if file_name:
            self.image_path = file_name
            self.pixmap = QPixmap(file_name)
            self.scene = QGraphicsScene(self)
            self.scene.addPixmap(self.pixmap)

            self.scale_factor = 0.54
            self.tabImage_graphicsView.setScene(self.scene)
            self.tabImage_graphicsView.scale(self.scale_factor, self.scale_factor)

            self.tabImage_pushPredict.setEnabled(True)

    def predict_image_2(self):
        self.scene = Vision.pred_photo(self.image_path)
        self.tabImage_graphicsView.setScene(self.scene)


    # --- --- --- --- --- --- --- --- --- --- --- ---
    # QThreadPool

    def video(self):
        self.video_tab_ThreadPool()
        self.start_webcam()

    def video_tab_ThreadPool(self):
        self.thread_pool = QThreadPool()
        self.webcam_runnable = VideoPlayer.VideoCaptureWorker(self.tabCamera_label)

    def start_webcam(self):
        self.webcam_runnable = VideoPlayer.VideoCaptureWorker(self.tabCamera_label)
        self.thread_pool.start(self.webcam_runnable)

    def stop_webcam(self):
        if self.webcam_runnable is not None:
            self.webcam_runnable.stop_capture()
        self.tabCamera_label.clear()

    def pause_video(self):
        if self.webcam_runnable is not None:
            self.webcam_runnable.pause()

    def start_predict(self):
        if not self.is_predict:
            self.is_predict = True
            self.run_flag = True
            self.tabCamera_pushPredict.setText('Stop')
            self.thread_pool.start(self.video_prediction)
        else:
            self.is_predict = False
            self.run_flag = False
            self.tabCamera_pushPredict.setText('Predict')
            self.tabCamera_label.clear()
            self.thread_pool.clear()

    # --- --- --- --- --- --- --- --- --- --- --- ---
    # Prediction

    def video_prediction(self):

        model_path = 'best.pt'
        model = YOLO(model_path)
        cap = cv2.VideoCapture(0)

        colors = [ (255, 0, 0), (0, 255, 0), (0, 0, 255) ]

        root = ET.Element("Frames")

        with open('output.txt', 'w') as file:
            pass

        frame_number = 0
        while self.run_flag:
            ret, frame = cap.read()
            if ret:

                results = model(frame)[0]
                detections = results.boxes
                class_ids = [int(det.cls[0]) for det in detections]
                class_counts = Counter(class_ids)

                classes = {0: 'fire', 1: 'smoke'}

                class_info = ', '.join([f'{classes[class_id]} - {count}' for class_id, count in class_counts.items()])

                locations = []
                sizes = []

                class_object_count = {class_id: 0 for class_id in classes.keys()}

                for det in detections:
                    class_id = int(det.cls[0])
                    class_object_count[class_id] += 1

                    x1, y1, x2, y2 = map(int, det.xyxy[0])
                    width = x2 - x1
                    height = y2 - y1

                    center_x = (x1 + x2) / 2
                    center_y = (y1 + y2) / 2

                    object_number = class_object_count[class_id]
                    location_str = f"{classes[class_id]}.{object_number} - ({center_x:.2f}, {center_y:.2f})"
                    size_str = f"{classes[class_id]}.{object_number} - ({width}, {height})"

                    locations.append(location_str)
                    sizes.append(size_str)


                frame_element = ET.SubElement(root, "Frame", number=str(frame_number))
                ET.SubElement(frame_element, "Classes").text = class_info
                locations_element = ET.SubElement(frame_element, "Locations")
                for loc in locations:
                    ET.SubElement(locations_element, "Location").text = loc
                sizes_element = ET.SubElement(frame_element, "Sizes")
                for size in sizes:
                    ET.SubElement(sizes_element, "Size").text = size


                with open('output.txt', 'a') as f:
                    f.write(f"[{frame_number}, ({class_info}), {locations}, {sizes}]\n")

                classes_names = results.names
                classes = results.boxes.cls.cpu().numpy()
                boxes = results.boxes.xyxy.cpu().numpy().astype(np.int32)
                for class_id, box, conf in zip(classes, boxes, results.boxes.conf):
                    if conf > 0.5:
                        class_name = classes_names[int(class_id)]
                        color = colors[int(class_id) % len(colors)]
                        x1, y1, x2, y2 = box
                        cv2.rectangle(frame, (x1, y1), (x2, y2), color, 2)
                        cv2.putText(frame, class_name, (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)

                height, width, channel = frame.shape
                bytes_per_line = 3 * width

                frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

                image = QImage(frame_rgb.data, width, height,
                                                 bytes_per_line,
                                                 QImage.Format_RGB888)

                q_img = QPixmap.fromImage(image).scaled(self.tabCamera_label.size(), Qt.KeepAspectRatio,
                                                         Qt.SmoothTransformation)

                self.tabCamera_label.setPixmap(q_img)
                time.sleep(1 / 10)
                frame_number += 1
            else:
                break

        # tree = ET.ElementTree(root)
        xml_str = ET.tostring(root, encoding='utf-8', method='xml')
        parsed_xml = minidom.parseString(xml_str)
        pretty_xml_str = parsed_xml.toprettyxml(indent="  ")
        with open("output.xml", "w") as xml_file:
            xml_file.write(pretty_xml_str)

        cap.release()



    # --- --- --- --- --- --- --- --- --- --- --- ---